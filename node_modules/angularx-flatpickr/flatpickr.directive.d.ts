import { ElementRef, AfterViewInit, EventEmitter, OnChanges, SimpleChanges, OnDestroy, Renderer2 } from '@angular/core';
import { FlatpickrDefaults, DisableEnableDate, FlatpickrDefaultsInterface } from './flatpickr-defaults.service';
import { ControlValueAccessor } from '@angular/forms';
import * as ɵngcc0 from '@angular/core';
export interface FlatPickrOutputOptions {
    selectedDates: Date[];
    dateString: string;
    instance: any;
}
export interface FlatPickrDayCreateOutputOptions extends FlatPickrOutputOptions {
    dayElement: HTMLElement;
}
export declare const FLATPICKR_CONTROL_VALUE_ACCESSOR: any;
export declare class FlatpickrDirective implements AfterViewInit, OnChanges, OnDestroy, ControlValueAccessor {
    private elm;
    private defaults;
    private renderer;
    /**
     * Object-options that can be user for multiple instances of Flatpickr.
     * Option from this object is applied only if specific option is not specified.
     * Example:
     * ```typescript
     * options: FlatpickrDefaultsInterface = {
     *      altFormat: 'd/m/Y',   // will be ignored since altFormat is provided via specific attribute
     *      altInput: true        // will be used since specific attribute is not provided
     * };
     * ```
     * ```html
     * <input
     *   class="form-control"
     *   type="text"
     *   mwlFlatpickr
     *   [options]="options"
     *   altFormat="d/m/Y">
     * ```
     */
    options: FlatpickrDefaultsInterface;
    /**
     * Exactly the same as date format, but for the altInput field.
     */
    altFormat: string;
    /**
     * 	Show the user a readable date (as per altFormat), but return something totally different to the server.
     */
    altInput: boolean;
    /**
     * This class will be added to the input element created by the altInput option.
     * Note that `altInput` already inherits classes from the original input.
     */
    altInputClass: string;
    /**
     * Allows the user to enter a date directly input the input field. By default, direct entry is disabled.
     */
    allowInput: boolean;
    /**
     * Instead of `body`, appends the calendar to the specified node instead.
     */
    appendTo: HTMLElement;
    /**
     * Defines how the date will be formatted in the aria-label for calendar days, using the same tokens as dateFormat. If you change this, you should choose a value that will make sense if a screen reader reads it out loud.
     */
    ariaDateFormat?: string;
    /**
     * Whether clicking on the input should open the picker.
     * You could disable this if you wish to open the calendar manually `with.open()`.
     */
    clickOpens: boolean;
    /**
     * A string of characters which are used to define how the date will be displayed in the input box.
     * The supported characters are defined in the table below.
     */
    dateFormat: string;
    /**
     * Initial value of the hour element.
     */
    defaultHour?: number;
    /**
     * Initial value of the minute element.
     */
    defaultMinute?: number;
    /**
     * Initial value of the seconds element.
     */
    defaultSeconds?: number;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-specific-dates">disabling dates</a>.
     */
    disable: DisableEnableDate[];
    /**
     * Set disableMobile to true to always use the non-native picker.
     * By default, Flatpickr utilizes native datetime widgets unless certain options (e.g. disable) are used.
     */
    disableMobile: boolean;
    /**
     * See <a href="https://chmln.github.io/flatpickr/examples/#disabling-all-dates-except-select-few">enabling dates</a>.
     */
    enable: DisableEnableDate[];
    /**
     * Enables time picker.
     */
    enableTime: boolean;
    /**
     * Enables seconds in the time picker.
     */
    enableSeconds: boolean;
    /**
     * Allows using a custom date formatting function instead of the built-in handling for date formats using dateFormat, altFormat, etc.
     */
    formatDate?: (value: any) => string;
    /**
     * Adjusts the step for the hour input (incl. scrolling).
     */
    hourIncrement: number;
    /**
     * Displays the calendar inline.
     */
    inline: boolean;
    /**
     * The maximum date that a user can pick to (inclusive).
     */
    maxDate: string | Date;
    /**
     * The minimum date that a user can start picking from (inclusive).
     */
    minDate: string | Date;
    /**
     * Adjusts the step for the minute input (incl. scrolling).
     */
    minuteIncrement: number;
    /**
     * Select a single date, multiple dates or a date range.
     */
    mode: 'single' | 'multiple' | 'range';
    /**
     * HTML for the arrow icon, used to switch months.
     */
    nextArrow: string;
    /**
     * Hides the day selection in calendar. Use it along with `enableTime` to create a time picker.
     */
    noCalendar: boolean;
    /**
     * Provide a date for 'today', which will be used instead of "new Date()"
     */
    now?: Date | string | number;
    /**
     * Function that expects a date string and must return a Date object.
     */
    parseDate: (str: string) => Date;
    /**
     * HTML for the left arrow icon.
     */
    prevArrow: string;
    /**
     * Show the month using the shorthand version (ie, Sep instead of September).
     */
    shorthandCurrentMonth: boolean;
    /**
     * The number of months shown.
     */
    showMonths: number;
    /**
     * Position the calendar inside the wrapper and next to the input element. (Leave `false` unless you know what you're doing).
     */
    static: boolean;
    /**
     * Displays time picker in 24 hour mode without AM/PM selection when enabled.
     */
    time24hr: boolean;
    /**
     * Enables display of week numbers in calendar.
     */
    weekNumbers: boolean;
    /**
     * You may override the function that extracts the week numbers from a Date by supplying a getWeek function.
     * It takes in a date as a parameter and should return a corresponding string that you want to appear left of every week.
     */
    getWeek: (date: Date) => string;
    /**
     * Custom elements and input groups.
     */
    wrap: boolean;
    /**
     * Array of plugin instances to use.
     */
    plugins: any[];
    /**
     * The locale object or string to use for the locale.
     */
    locale: object | string;
    /**
     * Auto convert the ngModel value from a string to a date / array of dates / from - to date object depending on the `mode`
     */
    convertModelValue: boolean;
    /**
     * How the month should be displayed in the header of the calendar.
     */
    monthSelectorType: 'static' | 'dropdown';
    /**
     * Gets triggered once the calendar is in a ready state
     */
    flatpickrReady: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the user selects a date, or changes the time on a selected date.
     */
    flatpickrChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the input value is updated with a new date string.
     */
    flatpickrValueUpdate: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the calendar is opened.
     */
    flatpickrOpen: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the calendar is closed.
     */
    flatpickrClose: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the month is changed, either by the user or programmatically.
     */
    flatpickrMonthChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Gets triggered when the year is changed, either by the user or programmatically.
     */
    flatpickrYearChange: EventEmitter<FlatPickrOutputOptions>;
    /**
     * Take full control of every date cell with this output
     */
    flatpickrDayCreate: EventEmitter<FlatPickrDayCreateOutputOptions>;
    private instance;
    private isDisabled;
    private initialValue;
    onChangeFn: (value: any) => void;
    onTouchedFn: () => void;
    constructor(elm: ElementRef, defaults: FlatpickrDefaults, renderer: Renderer2);
    ngAfterViewInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    ngOnDestroy(): void;
    writeValue(value: any): void;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: () => void): void;
    setDisabledState(isDisabled: boolean): void;
    inputChanged(): void;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<FlatpickrDirective>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<FlatpickrDirective, "[mwlFlatpickr]", never, {
    "options": "options";
    "altFormat": "altFormat";
    "altInput": "altInput";
    "altInputClass": "altInputClass";
    "allowInput": "allowInput";
    "appendTo": "appendTo";
    "ariaDateFormat": "ariaDateFormat";
    "clickOpens": "clickOpens";
    "dateFormat": "dateFormat";
    "defaultHour": "defaultHour";
    "defaultMinute": "defaultMinute";
    "defaultSeconds": "defaultSeconds";
    "disable": "disable";
    "disableMobile": "disableMobile";
    "enable": "enable";
    "enableTime": "enableTime";
    "enableSeconds": "enableSeconds";
    "formatDate": "formatDate";
    "hourIncrement": "hourIncrement";
    "inline": "inline";
    "maxDate": "maxDate";
    "minDate": "minDate";
    "minuteIncrement": "minuteIncrement";
    "mode": "mode";
    "nextArrow": "nextArrow";
    "noCalendar": "noCalendar";
    "now": "now";
    "parseDate": "parseDate";
    "prevArrow": "prevArrow";
    "shorthandCurrentMonth": "shorthandCurrentMonth";
    "showMonths": "showMonths";
    "static": "static";
    "time24hr": "time24hr";
    "weekNumbers": "weekNumbers";
    "getWeek": "getWeek";
    "wrap": "wrap";
    "plugins": "plugins";
    "locale": "locale";
    "convertModelValue": "convertModelValue";
    "monthSelectorType": "monthSelectorType";
}, {
    "flatpickrReady": "flatpickrReady";
    "flatpickrChange": "flatpickrChange";
    "flatpickrValueUpdate": "flatpickrValueUpdate";
    "flatpickrOpen": "flatpickrOpen";
    "flatpickrClose": "flatpickrClose";
    "flatpickrMonthChange": "flatpickrMonthChange";
    "flatpickrYearChange": "flatpickrYearChange";
    "flatpickrDayCreate": "flatpickrDayCreate";
}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhdHBpY2tyLmRpcmVjdGl2ZS5kLnRzIiwic291cmNlcyI6WyJmbGF0cGlja3IuZGlyZWN0aXZlLmQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7QUFHQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQWdQQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYsIEFmdGVyVmlld0luaXQsIEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBTaW1wbGVDaGFuZ2VzLCBPbkRlc3Ryb3ksIFJlbmRlcmVyMiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRmxhdHBpY2tyRGVmYXVsdHMsIERpc2FibGVFbmFibGVEYXRlLCBGbGF0cGlja3JEZWZhdWx0c0ludGVyZmFjZSB9IGZyb20gJy4vZmxhdHBpY2tyLWRlZmF1bHRzLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29udHJvbFZhbHVlQWNjZXNzb3IgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5leHBvcnQgaW50ZXJmYWNlIEZsYXRQaWNrck91dHB1dE9wdGlvbnMge1xuICAgIHNlbGVjdGVkRGF0ZXM6IERhdGVbXTtcbiAgICBkYXRlU3RyaW5nOiBzdHJpbmc7XG4gICAgaW5zdGFuY2U6IGFueTtcbn1cbmV4cG9ydCBpbnRlcmZhY2UgRmxhdFBpY2tyRGF5Q3JlYXRlT3V0cHV0T3B0aW9ucyBleHRlbmRzIEZsYXRQaWNrck91dHB1dE9wdGlvbnMge1xuICAgIGRheUVsZW1lbnQ6IEhUTUxFbGVtZW50O1xufVxuZXhwb3J0IGRlY2xhcmUgY29uc3QgRkxBVFBJQ0tSX0NPTlRST0xfVkFMVUVfQUNDRVNTT1I6IGFueTtcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEZsYXRwaWNrckRpcmVjdGl2ZSBpbXBsZW1lbnRzIEFmdGVyVmlld0luaXQsIE9uQ2hhbmdlcywgT25EZXN0cm95LCBDb250cm9sVmFsdWVBY2Nlc3NvciB7XG4gICAgcHJpdmF0ZSBlbG07XG4gICAgcHJpdmF0ZSBkZWZhdWx0cztcbiAgICBwcml2YXRlIHJlbmRlcmVyO1xuICAgIC8qKlxuICAgICAqIE9iamVjdC1vcHRpb25zIHRoYXQgY2FuIGJlIHVzZXIgZm9yIG11bHRpcGxlIGluc3RhbmNlcyBvZiBGbGF0cGlja3IuXG4gICAgICogT3B0aW9uIGZyb20gdGhpcyBvYmplY3QgaXMgYXBwbGllZCBvbmx5IGlmIHNwZWNpZmljIG9wdGlvbiBpcyBub3Qgc3BlY2lmaWVkLlxuICAgICAqIEV4YW1wbGU6XG4gICAgICogYGBgdHlwZXNjcmlwdFxuICAgICAqIG9wdGlvbnM6IEZsYXRwaWNrckRlZmF1bHRzSW50ZXJmYWNlID0ge1xuICAgICAqICAgICAgYWx0Rm9ybWF0OiAnZC9tL1knLCAgIC8vIHdpbGwgYmUgaWdub3JlZCBzaW5jZSBhbHRGb3JtYXQgaXMgcHJvdmlkZWQgdmlhIHNwZWNpZmljIGF0dHJpYnV0ZVxuICAgICAqICAgICAgYWx0SW5wdXQ6IHRydWUgICAgICAgIC8vIHdpbGwgYmUgdXNlZCBzaW5jZSBzcGVjaWZpYyBhdHRyaWJ1dGUgaXMgbm90IHByb3ZpZGVkXG4gICAgICogfTtcbiAgICAgKiBgYGBcbiAgICAgKiBgYGBodG1sXG4gICAgICogPGlucHV0XG4gICAgICogICBjbGFzcz1cImZvcm0tY29udHJvbFwiXG4gICAgICogICB0eXBlPVwidGV4dFwiXG4gICAgICogICBtd2xGbGF0cGlja3JcbiAgICAgKiAgIFtvcHRpb25zXT1cIm9wdGlvbnNcIlxuICAgICAqICAgYWx0Rm9ybWF0PVwiZC9tL1lcIj5cbiAgICAgKiBgYGBcbiAgICAgKi9cbiAgICBvcHRpb25zOiBGbGF0cGlja3JEZWZhdWx0c0ludGVyZmFjZTtcbiAgICAvKipcbiAgICAgKiBFeGFjdGx5IHRoZSBzYW1lIGFzIGRhdGUgZm9ybWF0LCBidXQgZm9yIHRoZSBhbHRJbnB1dCBmaWVsZC5cbiAgICAgKi9cbiAgICBhbHRGb3JtYXQ6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBcdFNob3cgdGhlIHVzZXIgYSByZWFkYWJsZSBkYXRlIChhcyBwZXIgYWx0Rm9ybWF0KSwgYnV0IHJldHVybiBzb21ldGhpbmcgdG90YWxseSBkaWZmZXJlbnQgdG8gdGhlIHNlcnZlci5cbiAgICAgKi9cbiAgICBhbHRJbnB1dDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGNsYXNzIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGlucHV0IGVsZW1lbnQgY3JlYXRlZCBieSB0aGUgYWx0SW5wdXQgb3B0aW9uLlxuICAgICAqIE5vdGUgdGhhdCBgYWx0SW5wdXRgIGFscmVhZHkgaW5oZXJpdHMgY2xhc3NlcyBmcm9tIHRoZSBvcmlnaW5hbCBpbnB1dC5cbiAgICAgKi9cbiAgICBhbHRJbnB1dENsYXNzOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogQWxsb3dzIHRoZSB1c2VyIHRvIGVudGVyIGEgZGF0ZSBkaXJlY3RseSBpbnB1dCB0aGUgaW5wdXQgZmllbGQuIEJ5IGRlZmF1bHQsIGRpcmVjdCBlbnRyeSBpcyBkaXNhYmxlZC5cbiAgICAgKi9cbiAgICBhbGxvd0lucHV0OiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEluc3RlYWQgb2YgYGJvZHlgLCBhcHBlbmRzIHRoZSBjYWxlbmRhciB0byB0aGUgc3BlY2lmaWVkIG5vZGUgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBhcHBlbmRUbzogSFRNTEVsZW1lbnQ7XG4gICAgLyoqXG4gICAgICogRGVmaW5lcyBob3cgdGhlIGRhdGUgd2lsbCBiZSBmb3JtYXR0ZWQgaW4gdGhlIGFyaWEtbGFiZWwgZm9yIGNhbGVuZGFyIGRheXMsIHVzaW5nIHRoZSBzYW1lIHRva2VucyBhcyBkYXRlRm9ybWF0LiBJZiB5b3UgY2hhbmdlIHRoaXMsIHlvdSBzaG91bGQgY2hvb3NlIGEgdmFsdWUgdGhhdCB3aWxsIG1ha2Ugc2Vuc2UgaWYgYSBzY3JlZW4gcmVhZGVyIHJlYWRzIGl0IG91dCBsb3VkLlxuICAgICAqL1xuICAgIGFyaWFEYXRlRm9ybWF0Pzogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgY2xpY2tpbmcgb24gdGhlIGlucHV0IHNob3VsZCBvcGVuIHRoZSBwaWNrZXIuXG4gICAgICogWW91IGNvdWxkIGRpc2FibGUgdGhpcyBpZiB5b3Ugd2lzaCB0byBvcGVuIHRoZSBjYWxlbmRhciBtYW51YWxseSBgd2l0aC5vcGVuKClgLlxuICAgICAqL1xuICAgIGNsaWNrT3BlbnM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQSBzdHJpbmcgb2YgY2hhcmFjdGVycyB3aGljaCBhcmUgdXNlZCB0byBkZWZpbmUgaG93IHRoZSBkYXRlIHdpbGwgYmUgZGlzcGxheWVkIGluIHRoZSBpbnB1dCBib3guXG4gICAgICogVGhlIHN1cHBvcnRlZCBjaGFyYWN0ZXJzIGFyZSBkZWZpbmVkIGluIHRoZSB0YWJsZSBiZWxvdy5cbiAgICAgKi9cbiAgICBkYXRlRm9ybWF0OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgaG91ciBlbGVtZW50LlxuICAgICAqL1xuICAgIGRlZmF1bHRIb3VyPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIEluaXRpYWwgdmFsdWUgb2YgdGhlIG1pbnV0ZSBlbGVtZW50LlxuICAgICAqL1xuICAgIGRlZmF1bHRNaW51dGU/OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbCB2YWx1ZSBvZiB0aGUgc2Vjb25kcyBlbGVtZW50LlxuICAgICAqL1xuICAgIGRlZmF1bHRTZWNvbmRzPzogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyL2V4YW1wbGVzLyNkaXNhYmxpbmctc3BlY2lmaWMtZGF0ZXNcIj5kaXNhYmxpbmcgZGF0ZXM8L2E+LlxuICAgICAqL1xuICAgIGRpc2FibGU6IERpc2FibGVFbmFibGVEYXRlW107XG4gICAgLyoqXG4gICAgICogU2V0IGRpc2FibGVNb2JpbGUgdG8gdHJ1ZSB0byBhbHdheXMgdXNlIHRoZSBub24tbmF0aXZlIHBpY2tlci5cbiAgICAgKiBCeSBkZWZhdWx0LCBGbGF0cGlja3IgdXRpbGl6ZXMgbmF0aXZlIGRhdGV0aW1lIHdpZGdldHMgdW5sZXNzIGNlcnRhaW4gb3B0aW9ucyAoZS5nLiBkaXNhYmxlKSBhcmUgdXNlZC5cbiAgICAgKi9cbiAgICBkaXNhYmxlTW9iaWxlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFNlZSA8YSBocmVmPVwiaHR0cHM6Ly9jaG1sbi5naXRodWIuaW8vZmxhdHBpY2tyL2V4YW1wbGVzLyNkaXNhYmxpbmctYWxsLWRhdGVzLWV4Y2VwdC1zZWxlY3QtZmV3XCI+ZW5hYmxpbmcgZGF0ZXM8L2E+LlxuICAgICAqL1xuICAgIGVuYWJsZTogRGlzYWJsZUVuYWJsZURhdGVbXTtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRpbWUgcGlja2VyLlxuICAgICAqL1xuICAgIGVuYWJsZVRpbWU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRW5hYmxlcyBzZWNvbmRzIGluIHRoZSB0aW1lIHBpY2tlci5cbiAgICAgKi9cbiAgICBlbmFibGVTZWNvbmRzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEFsbG93cyB1c2luZyBhIGN1c3RvbSBkYXRlIGZvcm1hdHRpbmcgZnVuY3Rpb24gaW5zdGVhZCBvZiB0aGUgYnVpbHQtaW4gaGFuZGxpbmcgZm9yIGRhdGUgZm9ybWF0cyB1c2luZyBkYXRlRm9ybWF0LCBhbHRGb3JtYXQsIGV0Yy5cbiAgICAgKi9cbiAgICBmb3JtYXREYXRlPzogKHZhbHVlOiBhbnkpID0+IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBZGp1c3RzIHRoZSBzdGVwIGZvciB0aGUgaG91ciBpbnB1dCAoaW5jbC4gc2Nyb2xsaW5nKS5cbiAgICAgKi9cbiAgICBob3VySW5jcmVtZW50OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgdGhlIGNhbGVuZGFyIGlubGluZS5cbiAgICAgKi9cbiAgICBpbmxpbmU6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogVGhlIG1heGltdW0gZGF0ZSB0aGF0IGEgdXNlciBjYW4gcGljayB0byAoaW5jbHVzaXZlKS5cbiAgICAgKi9cbiAgICBtYXhEYXRlOiBzdHJpbmcgfCBEYXRlO1xuICAgIC8qKlxuICAgICAqIFRoZSBtaW5pbXVtIGRhdGUgdGhhdCBhIHVzZXIgY2FuIHN0YXJ0IHBpY2tpbmcgZnJvbSAoaW5jbHVzaXZlKS5cbiAgICAgKi9cbiAgICBtaW5EYXRlOiBzdHJpbmcgfCBEYXRlO1xuICAgIC8qKlxuICAgICAqIEFkanVzdHMgdGhlIHN0ZXAgZm9yIHRoZSBtaW51dGUgaW5wdXQgKGluY2wuIHNjcm9sbGluZykuXG4gICAgICovXG4gICAgbWludXRlSW5jcmVtZW50OiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogU2VsZWN0IGEgc2luZ2xlIGRhdGUsIG11bHRpcGxlIGRhdGVzIG9yIGEgZGF0ZSByYW5nZS5cbiAgICAgKi9cbiAgICBtb2RlOiAnc2luZ2xlJyB8ICdtdWx0aXBsZScgfCAncmFuZ2UnO1xuICAgIC8qKlxuICAgICAqIEhUTUwgZm9yIHRoZSBhcnJvdyBpY29uLCB1c2VkIHRvIHN3aXRjaCBtb250aHMuXG4gICAgICovXG4gICAgbmV4dEFycm93OiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogSGlkZXMgdGhlIGRheSBzZWxlY3Rpb24gaW4gY2FsZW5kYXIuIFVzZSBpdCBhbG9uZyB3aXRoIGBlbmFibGVUaW1lYCB0byBjcmVhdGUgYSB0aW1lIHBpY2tlci5cbiAgICAgKi9cbiAgICBub0NhbGVuZGFyOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBkYXRlIGZvciAndG9kYXknLCB3aGljaCB3aWxsIGJlIHVzZWQgaW5zdGVhZCBvZiBcIm5ldyBEYXRlKClcIlxuICAgICAqL1xuICAgIG5vdz86IERhdGUgfCBzdHJpbmcgfCBudW1iZXI7XG4gICAgLyoqXG4gICAgICogRnVuY3Rpb24gdGhhdCBleHBlY3RzIGEgZGF0ZSBzdHJpbmcgYW5kIG11c3QgcmV0dXJuIGEgRGF0ZSBvYmplY3QuXG4gICAgICovXG4gICAgcGFyc2VEYXRlOiAoc3RyOiBzdHJpbmcpID0+IERhdGU7XG4gICAgLyoqXG4gICAgICogSFRNTCBmb3IgdGhlIGxlZnQgYXJyb3cgaWNvbi5cbiAgICAgKi9cbiAgICBwcmV2QXJyb3c6IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBTaG93IHRoZSBtb250aCB1c2luZyB0aGUgc2hvcnRoYW5kIHZlcnNpb24gKGllLCBTZXAgaW5zdGVhZCBvZiBTZXB0ZW1iZXIpLlxuICAgICAqL1xuICAgIHNob3J0aGFuZEN1cnJlbnRNb250aDogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG1vbnRocyBzaG93bi5cbiAgICAgKi9cbiAgICBzaG93TW9udGhzOiBudW1iZXI7XG4gICAgLyoqXG4gICAgICogUG9zaXRpb24gdGhlIGNhbGVuZGFyIGluc2lkZSB0aGUgd3JhcHBlciBhbmQgbmV4dCB0byB0aGUgaW5wdXQgZWxlbWVudC4gKExlYXZlIGBmYWxzZWAgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nKS5cbiAgICAgKi9cbiAgICBzdGF0aWM6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogRGlzcGxheXMgdGltZSBwaWNrZXIgaW4gMjQgaG91ciBtb2RlIHdpdGhvdXQgQU0vUE0gc2VsZWN0aW9uIHdoZW4gZW5hYmxlZC5cbiAgICAgKi9cbiAgICB0aW1lMjRocjogYm9vbGVhbjtcbiAgICAvKipcbiAgICAgKiBFbmFibGVzIGRpc3BsYXkgb2Ygd2VlayBudW1iZXJzIGluIGNhbGVuZGFyLlxuICAgICAqL1xuICAgIHdlZWtOdW1iZXJzOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIFlvdSBtYXkgb3ZlcnJpZGUgdGhlIGZ1bmN0aW9uIHRoYXQgZXh0cmFjdHMgdGhlIHdlZWsgbnVtYmVycyBmcm9tIGEgRGF0ZSBieSBzdXBwbHlpbmcgYSBnZXRXZWVrIGZ1bmN0aW9uLlxuICAgICAqIEl0IHRha2VzIGluIGEgZGF0ZSBhcyBhIHBhcmFtZXRlciBhbmQgc2hvdWxkIHJldHVybiBhIGNvcnJlc3BvbmRpbmcgc3RyaW5nIHRoYXQgeW91IHdhbnQgdG8gYXBwZWFyIGxlZnQgb2YgZXZlcnkgd2Vlay5cbiAgICAgKi9cbiAgICBnZXRXZWVrOiAoZGF0ZTogRGF0ZSkgPT4gc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIEN1c3RvbSBlbGVtZW50cyBhbmQgaW5wdXQgZ3JvdXBzLlxuICAgICAqL1xuICAgIHdyYXA6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2YgcGx1Z2luIGluc3RhbmNlcyB0byB1c2UuXG4gICAgICovXG4gICAgcGx1Z2luczogYW55W107XG4gICAgLyoqXG4gICAgICogVGhlIGxvY2FsZSBvYmplY3Qgb3Igc3RyaW5nIHRvIHVzZSBmb3IgdGhlIGxvY2FsZS5cbiAgICAgKi9cbiAgICBsb2NhbGU6IG9iamVjdCB8IHN0cmluZztcbiAgICAvKipcbiAgICAgKiBBdXRvIGNvbnZlcnQgdGhlIG5nTW9kZWwgdmFsdWUgZnJvbSBhIHN0cmluZyB0byBhIGRhdGUgLyBhcnJheSBvZiBkYXRlcyAvIGZyb20gLSB0byBkYXRlIG9iamVjdCBkZXBlbmRpbmcgb24gdGhlIGBtb2RlYFxuICAgICAqL1xuICAgIGNvbnZlcnRNb2RlbFZhbHVlOiBib29sZWFuO1xuICAgIC8qKlxuICAgICAqIEhvdyB0aGUgbW9udGggc2hvdWxkIGJlIGRpc3BsYXllZCBpbiB0aGUgaGVhZGVyIG9mIHRoZSBjYWxlbmRhci5cbiAgICAgKi9cbiAgICBtb250aFNlbGVjdG9yVHlwZTogJ3N0YXRpYycgfCAnZHJvcGRvd24nO1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIG9uY2UgdGhlIGNhbGVuZGFyIGlzIGluIGEgcmVhZHkgc3RhdGVcbiAgICAgKi9cbiAgICBmbGF0cGlja3JSZWFkeTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIHVzZXIgc2VsZWN0cyBhIGRhdGUsIG9yIGNoYW5nZXMgdGhlIHRpbWUgb24gYSBzZWxlY3RlZCBkYXRlLlxuICAgICAqL1xuICAgIGZsYXRwaWNrckNoYW5nZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIGlucHV0IHZhbHVlIGlzIHVwZGF0ZWQgd2l0aCBhIG5ldyBkYXRlIHN0cmluZy5cbiAgICAgKi9cbiAgICBmbGF0cGlja3JWYWx1ZVVwZGF0ZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrck91dHB1dE9wdGlvbnM+O1xuICAgIC8qKlxuICAgICAqIEdldHMgdHJpZ2dlcmVkIHdoZW4gdGhlIGNhbGVuZGFyIGlzIG9wZW5lZC5cbiAgICAgKi9cbiAgICBmbGF0cGlja3JPcGVuOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgY2FsZW5kYXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGZsYXRwaWNrckNsb3NlOiBFdmVudEVtaXR0ZXI8RmxhdFBpY2tyT3V0cHV0T3B0aW9ucz47XG4gICAgLyoqXG4gICAgICogR2V0cyB0cmlnZ2VyZWQgd2hlbiB0aGUgbW9udGggaXMgY2hhbmdlZCwgZWl0aGVyIGJ5IHRoZSB1c2VyIG9yIHByb2dyYW1tYXRpY2FsbHkuXG4gICAgICovXG4gICAgZmxhdHBpY2tyTW9udGhDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBHZXRzIHRyaWdnZXJlZCB3aGVuIHRoZSB5ZWFyIGlzIGNoYW5nZWQsIGVpdGhlciBieSB0aGUgdXNlciBvciBwcm9ncmFtbWF0aWNhbGx5LlxuICAgICAqL1xuICAgIGZsYXRwaWNrclllYXJDaGFuZ2U6IEV2ZW50RW1pdHRlcjxGbGF0UGlja3JPdXRwdXRPcHRpb25zPjtcbiAgICAvKipcbiAgICAgKiBUYWtlIGZ1bGwgY29udHJvbCBvZiBldmVyeSBkYXRlIGNlbGwgd2l0aCB0aGlzIG91dHB1dFxuICAgICAqL1xuICAgIGZsYXRwaWNrckRheUNyZWF0ZTogRXZlbnRFbWl0dGVyPEZsYXRQaWNrckRheUNyZWF0ZU91dHB1dE9wdGlvbnM+O1xuICAgIHByaXZhdGUgaW5zdGFuY2U7XG4gICAgcHJpdmF0ZSBpc0Rpc2FibGVkO1xuICAgIHByaXZhdGUgaW5pdGlhbFZhbHVlO1xuICAgIG9uQ2hhbmdlRm46ICh2YWx1ZTogYW55KSA9PiB2b2lkO1xuICAgIG9uVG91Y2hlZEZuOiAoKSA9PiB2b2lkO1xuICAgIGNvbnN0cnVjdG9yKGVsbTogRWxlbWVudFJlZiwgZGVmYXVsdHM6IEZsYXRwaWNrckRlZmF1bHRzLCByZW5kZXJlcjogUmVuZGVyZXIyKTtcbiAgICBuZ0FmdGVyVmlld0luaXQoKTogdm9pZDtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICBuZ09uRGVzdHJveSgpOiB2b2lkO1xuICAgIHdyaXRlVmFsdWUodmFsdWU6IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPbkNoYW5nZShmbjogYW55KTogdm9pZDtcbiAgICByZWdpc3Rlck9uVG91Y2hlZChmbjogKCkgPT4gdm9pZCk6IHZvaWQ7XG4gICAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZDtcbiAgICBpbnB1dENoYW5nZWQoKTogdm9pZDtcbn1cbiJdfQ==